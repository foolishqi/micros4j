## 定制模块
### **定制代码前端优化**
* 按应用将定制代码分离到独立项目中，运行时动态加载  
  **问题**  
  目前前端的定制代码集中在 codeService.js 文件中达到 9000+行代码量，当多名前端工程师修改同一文件时，将产生大量的版本冲突。而解决冲突的过程也非常容易导致代码丢失，影响工作效率。而且对不同租户的用户来说，浏览器在运行时加载所有应用的定制代码，及代码依赖的插件库，也消耗大量的网络、内存资源开销和并且存在安全隐患。  
  另外，前端框架采用即时编译技术，在混合了多个系统代码后，代码编译的速度严重下降，常见的现象是修改一小段代码，需要等编译2~5分钟后才能看到效果，也对日常的开发效率有所影响。当平台团队开发时其实并不需要编译定制代码，而定制团队开发时并不需要编译平台代码。通过分离平台和定制代码可有效提高编译速度。

  **目标**
  * 将平台和定制的代码分割到独立的项目中，有效的减少代码冲突问题。
  * 平台在运行时动态的按需加载定制扩展代码，提升应用的加载速度。
  * 开发调试的过程中，按需要编译平台或定制代码，加快编译速度。

  实现：
  1. 更新指定依赖包通过命令 npm install pkg
  2. 定制项目如何运行平台，并附加定制代码

* 改进定制编程方式，增强 SDK 能力  
  * 改善使用 UUID 编程方式的问题  
  通过包装器设计模式来对 UUID 封装，可能需要在代码层面进行声明性配置。
  * 通过 SDK 规范化操作控件、修改数据、与平台交互的方式

### **定制代码后端优化**
* 改善使用 UUID 硬编码的问题  
  利用配置表、列的别名，来简化编程的代码。通过拦截器，自动处理 别名 - UUID 的转换。
* 定制服务与业务数据库直接交互
  平台提供的方法无法灵活的支持定制代码，并且能减少中间层的开销。
* 建立 demo，规范化定制模块的分层结构
  目前的定制代码，无论是数据校验、数据处理、业务逻辑、数据访问逻辑全部混编在一个方法内部，带来了大量的耦合，造成代码阅读的困难。通过建立 Demo 实例项目，使开发人员转变开发思路，通过分层的约束性，避免代码混合在一起。

## 计算模块
### **计算模块后端代码优化**
重新实现计算模块，提供功能更完整，严谨，更高效的计算模块。
* 建立完整的数据类型体系，目前仅支持字符串
* 完善表达式语句分析功能，提供兼容性更强的表达式（如：-1， 2014-01-01，目前无法有效的识别各种格式和单词分割）
* 增强表达式校验能力，如格式校验、数据类型的校验、返回值的校验、区分设计时和运行时的校验
* 更友好的错误提示，指明表达式错误的位置【可选】
* 更高效的执行速度
* 测试驱动开发，更好的质量保障

### **表达式编辑器**
寻找一款好的表达式在线编辑器，引用或者借鉴来开发平台的表达式编辑器。提供表达式更好的设计能力。

### **引进 Kotlin 语言**
Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，由 JetBrains 设计开发并开源。Spring 官方推荐的 Java 体系编程语言，并且在 2017 年被 Google 宣布 Koltin 成为 Android 官方开发语言。

Kitlon 的优势是更为简洁，更加安全，更多的语法糖提高开发效率，对 Java 语言有很好的兼容性和互操作性。  
计划在重做计算模块引进 Kotlin 语言。

## 性能优化
### **分布式 ID 算法**
平台目前的`标识`使用的是`顺序UUID`标识算法，而有时数据处理人员使用的`无序UUID`来处理导入的数据。对于 Mysql 数据库，尤其是 InnoDB 引擎来说是非常低效的，当单表数据量达到百万级将会存在2~3倍的差距。原因如下：
1. UUID 使用 36个字符来表示唯一标识，UTF-8 格式下需要占用 111 byte。而 Long 类型的主键仅使用 8 byte 空间。
    * InnoDB 引擎存储数据是以主键聚集存储，主键作为数据的指针。因此在数据操作的过程中，更大的主键带来更多的性能开销。
    * 通常主键、外键、数据关联通常都是基于标识，索引优化也通常建立在标识列上，更大的索引列占据了更多的索引空间。
    > 例如：**合同录入表**，总数据 56W行，数据大小占 1,662 GB，而索引占用 2,023 GB 的空间，已经超过数据本身的大小。
2. 由于无序UUID在 insert 的时候，不一定会比先前的键值更大，因此可能导致已经存储在磁盘上的 pages 重新读取、整理、分裂、存储，导致数据大量的随机分布。
    * 数据读取或写入是带来大量的随机I/O，降低性能。
    * 不连续的插入导致 InnoDB 不断地分割 pages 来创建更多的空间，并且创建出来的 pages 会是相当稀疏且有许多碎片。
    * 每个 pages 16KB，随机分布的数据和过于稀疏的 pages 导致不能有效的利用磁盘空间和内存空间。

Mysql 提供的自增性主键能很好的避免以上问题，但也是因为无法处理分布式 ID 冲突问题，以及平台需要在程序中分配 ID 而非数据库，因此当时采用的有序UUID来作为平台的标识。

目前的新解决方案使用 `雪花算法（snowflake）`，用于生成分布式ID（64 bit纯数字，有序）
> 雪花算法解析 结构 snowflake的结构如下(每部分用-分开):  
> 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000  
> 第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，  
> 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点），  
> 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）  
> 一共加起来刚好64位，为一个Long型。(转换成字符串长度为18)。
>
> Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。  
> 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），  
> 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。

ID 算法更换需要分别在 Java，JavaScript，C 语言中分别实现，已提供给开发人员使用。其中 C 语言版是为了提供 Mysql 插件使 Mysql 支持雪花算法生成 ID，以提供数据处理人员分配 ID，这部分还需要预研。  
另外除了需要实现算法以外，还需要对历史数据（包含定制代码）进行处理，可能会导致部分数据不一致的问题。

### **优化 Data 服务数据结构**
Data 服务提供平台数据的存储和读取能力，是平台操作业务数据的主要瓶颈，是查询超时、内存溢出的主要问题来源。  
良好的数据传输结构，能有效的提高内存使用率，减少数据传输的网络开销。利用时间换空间的方式改进。

## 平台架构
### **分布式事务框架**
微服务体系内无法通过事务确保进程之间的数据一致性，需要研究全局事务框架。

### **数据库读写分离**
将数据库写操作，和读操作分别指向主库从库。可以利用从库增强平台的数据读取性能。
![数据库拓扑](https://images2018.cnblogs.com/blog/1005447/201807/1005447-20180721085036565-548999880.png)

### **微服务分层框架优化**
经过一年的微服务实践经验，在分层架构上有更好的设计思路。减少模块之间的耦合和依赖。
目前已在[演示](https://github.com/mlacker/micros4j)项目中实践

### **配置中心加密**
已实现，但目前未应用。

### **异步消息队列实践**
目前已应用于消息模块，经过一段时间的使用非常稳定。可以逐渐扩展到其它使用异步消息队列的功能上。

### **更换微服务网关 Spring Cloud Gateway**

### **更换认证授权方案**
1. 使用 jwt 协议代替 OAuth2.0 认证（目前系统内实现的不完整）；
2. 在网关服务实现认证拦截，并将认证信息加入到请求当中。目前的方式很低效；
3. 对比 jwt 协议和 OAuth2.0 协议；

### **微服务熔断机制和故障自动下线**
研究当服务处于故障时能自动下线，避免提供故障服务。

### **降低熔断超时时长，优化接口执行速度**
保障服务高可用，过长的熔断时间将长期的占用线程资源，导致平台性能下降。

### **接口执行监控告警**
运行时对接口进行监控，用于性能优化统计分析。对执行耗时接口进行告警。

### **配置中心单点故障**
目前存在单点故障的问题。当配置服务宕机后，从生产环境到开发环境，新启动的微服务将不能正常启动。

### **配置中心动态刷新配置**
更新配置后无需重启服务生效，依赖异步消息队列

### **提升微服务项目构建速度**  
随着项目越来越庞大，构建过程也逐渐变慢。 
1. 利用 docker 文件缓存机制； 
2. 建立 maven 仓库，服务独立构建；

## 业务模块
### **嵌套报表实现**

### **报表设计前端优化改进**
优化报表设计中各个组件的交互方式，提升稳定性  
解决报表列和归档列的表达式设计问题
